"""
YouTube platform handler implementation.

This module implements the YouTube-specific logic for data crawling using the Apify API.
It handles YouTube URL validation, parameter transformation, and data extraction.
"""

import os
import re
from typing import Dict, Any, List, Optional
from datetime import datetime

from ..base import BasePlatformHandler


class YouTubeHandler(BasePlatformHandler):
    """YouTube-specific platform handler using Apify API."""
    
    def prepare_request_params(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Prepare YouTube-specific parameters for Apify API.
        
        Transforms generic parameters to Apify YouTube scraper format.
        Filter out internal tracking parameters and only send what Apify expects.
        
        Args:
            params: Generic parameters from user request
            
        Returns:
            Apify-compatible parameters for YouTube scraping
        """
        if not isinstance(params, dict):
            return {}
        
        # Build YouTube-specific parameters from the input
        youtube_params = {}
        
        # Map URL/startUrls
        if 'url' in params:
            youtube_params['startUrls'] = [{'url': params['url'], 'method': 'GET'}]
        elif 'startUrls' in params:
            youtube_params['startUrls'] = params['startUrls']
        
        # Map Apify-specific parameters (only if they exist in input)
        apify_params = [
            'dateFilter', 'downloadSubtitles', 'hasCC', 'hasLocation', 'hasSubtitles',
            'is360', 'is3D', 'is4K', 'isBought', 'isHD', 'isHDR', 'isLive', 'isVR180',
            'maxResultStreams', 'maxResults', 'maxResultsShorts', 'oldestPostDate',
            'preferAutoGeneratedSubtitles', 'saveSubsToKVS', 'sortVideosBy', 'sortingOrder',
            'videoType'
        ]
        
        for param in apify_params:
            if param in params:
                youtube_params[param] = params[param]
        
        # Set defaults if not provided
        if 'dateFilter' not in youtube_params:
            youtube_params['dateFilter'] = 'month'
        if 'videoType' not in youtube_params:
            youtube_params['videoType'] = 'video'
        if 'sortingOrder' not in youtube_params:
            youtube_params['sortingOrder'] = 'date'
        if 'maxResults' not in youtube_params:
            youtube_params['maxResults'] = 10
        if 'maxResultsShorts' not in youtube_params:
            youtube_params['maxResultsShorts'] = 10
        if 'isHD' not in youtube_params:
            youtube_params['isHD'] = True
        if 'hasSubtitles' not in youtube_params:
            youtube_params['hasSubtitles'] = True
        
        return youtube_params
    
    def validate_params(self, params: Dict[str, Any]) -> bool:
        """Validate YouTube parameters.
        
        Args:
            params: Parameters to validate
            
        Returns:
            True if parameters are valid for YouTube, False otherwise
        """
        # Check required fields
        for field in self.config.required_params:
            if field not in params or not params[field]:
                return False
        
        # Validate URL format for YouTube
        url = params.get('url', '')
        if not url:
            return False
            
        # Accept various YouTube URL formats
        youtube_patterns = [
            r'youtube\.com',
            r'youtu\.be'
        ]
        
        for pattern in youtube_patterns:
            if re.search(pattern, url, re.IGNORECASE):
                return True
                
        return False
    
    def extract_media_info(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract YouTube media information from video data.
        
        Args:
            data: Raw video data from Apify YouTube scraper
            
        Returns:
            Standardized media metadata dictionary
        """
        # Always parse duration, regardless of type (for testing purposes)
        duration = data.get('duration')
        duration_seconds = self._parse_duration_to_seconds(duration)
        
        # Check if this is a video entry
        if data.get('type') != 'video':
            return {
                'has_media': False,
                'media_count': 0,
                'media_types': [],
                'video_id': None,
                'video_url': None,
                'thumbnail': None,
                'duration': None,
                'view_count': 0,
                'duration_seconds': duration_seconds
            }
        
        # Extract basic video info
        video_id = data.get('id')
        video_url = data.get('url')
        thumbnail = data.get('thumbnailUrl')
        view_count = data.get('viewCount', 0)
        
        return {
            'has_media': True,
            'media_count': 1,
            'media_types': ['video'],
            'video_id': video_id,
            'video_url': video_url,
            'thumbnail': thumbnail,
            'duration': duration,
            'view_count': view_count,
            'duration_seconds': duration_seconds
        }
    
    def extract_channel_info(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract channel information from YouTube data.
        
        Args:
            data: Raw video data from Apify YouTube scraper
            
        Returns:
            Channel information dictionary
        """
        return {
            'channel_id': data.get('channelId'),
            'channel_name': data.get('channelName'),
            'channel_url': data.get('channelUrl')
        }
    
    def extract_content_info(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract content information from YouTube data.
        
        Args:
            data: Raw video data from Apify YouTube scraper
            
        Returns:
            Content information dictionary
        """
        return {
            'title': data.get('title'),
            'description': data.get('text', '')
        }
    
    def transform_metrics(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Transform YouTube-specific metrics to standardized format.
        
        Args:
            data: Raw video data from Apify YouTube scraper
            
        Returns:
            Standardized metrics dictionary
        """
        return {
            'views': data.get('viewCount', 0),
            'likes': data.get('likes', 0),
            'comments': data.get('commentsCount', 0),
            'channel_name': data.get('channelName'),
            'published_at': data.get('date')
        }
    
    def get_storage_path(self, snapshot_id: str, competitor: str, brand: str, category: str, timestamp: datetime) -> str:
        """Generate YouTube hierarchical storage path.
        
        Args:
            snapshot_id: Unique identifier for the crawl snapshot
            competitor: Competitor name for business context
            brand: Brand name for business context
            category: Category for business context
            timestamp: Timestamp when the crawl was performed
            
        Returns:
            Hierarchical GCS storage path with business context partitioning
        """
        return f"raw_snapshots/platform=youtube/competitor={competitor}/brand={brand}/category={category}/year={timestamp.year}/month={timestamp.month:02d}/day={timestamp.day:02d}/snapshot_{snapshot_id}.json"
    
    def get_api_client(self) -> Any:
        """Get Apify API client for YouTube.
        
        Returns:
            Configured Apify client instance
        """
        # API client is managed by the crawl handler
        # This method is not needed for the current architecture
        raise NotImplementedError("API client is managed externally")
    
    def parse_api_response(self, response: Any) -> List[Dict[str, Any]]:
        """Parse Apify response to standard format.
        
        Args:
            response: Raw response from Apify YouTube scraper
            
        Returns:
            List of video entries (filtered to only include videos)
        """
        if not isinstance(response, list):
            return []
        
        # Filter to only return video entries
        videos = []
        for item in response:
            if item.get('type') == 'video':
                videos.append(item)
        
        return videos
    
    def _parse_duration_to_seconds(self, duration: str) -> int:
        """Parse YouTube duration format (HH:MM:SS) to seconds.
        
        Args:
            duration: Duration string in HH:MM:SS format
            
        Returns:
            Duration in seconds
        """
        if not duration:
            return 0
        
        try:
            # Handle HH:MM:SS format
            parts = duration.split(':')
            if len(parts) == 3:
                hours, minutes, seconds = map(int, parts)
                return hours * 3600 + minutes * 60 + seconds
            elif len(parts) == 2:
                minutes, seconds = map(int, parts)
                return minutes * 60 + seconds
            elif len(parts) == 1:
                return int(parts[0])
        except (ValueError, TypeError):
            return 0
        
        return 0